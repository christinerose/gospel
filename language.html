
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Language Specification &#8212; GOSPEL dev documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Gospel API" href="api.html" />
    <link rel="prev" title="Example Tools" href="tools.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="language-specification">
<h1>Language Specification<a class="headerlink" href="#language-specification" title="Permalink to this headline">¶</a></h1>
<div class="section" id="specification-locations">
<h2>Specification locations<a class="headerlink" href="#specification-locations" title="Permalink to this headline">¶</a></h2>
<div class="section" id="general-conventions">
<h3>General conventions<a class="headerlink" href="#general-conventions" title="Permalink to this headline">¶</a></h3>
<p>Gospel annotations are written in interface files (<code class="docutils literal notranslate"><span class="pre">.mli</span></code>).</p>
<p><a class="reference external" href="https://caml.inria.fr/pub/docs/manual-ocaml/attributes.html">OCaml attributes</a>
with the identifier <code class="docutils literal notranslate"><span class="pre">gospel</span></code> are used to bear the Gospel specifications in their
payload, as strings: <code class="docutils literal notranslate"><span class="pre">[&#64;&#64;gospel</span> <span class="pre">&quot;&lt;spec&gt;&quot;]</span></code> or <code class="docutils literal notranslate"><span class="pre">[&#64;&#64;&#64;gospel</span> <span class="pre">&quot;&lt;spec&gt;&quot;]</span></code>.</p>
<p class="rubric">Floating attributes</p>
<p><a class="reference internal" href="#ghost-and-logical-declarations"><span class="std std-ref">Ghost and logical declarations</span></a> must lie
in floating attributes, inside module signatures:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">[@@@</span><span class="n">gospel</span> <span class="s2">&quot;val f : int -&gt; int&quot;</span><span class="o">]</span>
<span class="o">[@@@</span><span class="n">gospel</span> <span class="s2">&quot;predicate is_zero (x: integer) = x = 0&quot;</span><span class="o">]</span>
</pre></div>
</div>
<p class="rubric">Attached attributes</p>
<p>Specification bits which are semantically attached to OCaml declarations, e.g.
<a class="reference internal" href="#function-contracts"><span class="std std-ref">function contracts</span></a> or <a class="reference internal" href="#type-specification"><span class="std std-ref">type specifications</span></a> specifications. In that case, the Gospel specification
should be written in an attached attribute, following OCaml’s attachement rules:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">f</span><span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span>
<span class="o">[@@</span><span class="n">gospel</span> <span class="s2">&quot;y = f x ensures x &gt; 0&quot;</span><span class="o">]</span>
</pre></div>
</div>
<p class="rubric">Specification of ghost and logical declarations</p>
<p>When ghost and logical declarations need to be specified with a contract, the
contract should reside in an attribute attached to the string containing the
declaration:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">[@@@</span><span class="n">gospel</span> <span class="s2">&quot;val f : int -&gt; int&quot;</span>
  <span class="o">[@@</span><span class="n">gospel</span> <span class="s2">&quot;y = f x ensures x &gt; 0&quot;</span><span class="o">]]</span>
</pre></div>
</div>
</div>
<div class="section" id="gospel-preprocessor-gospel-pps">
<h3>Gospel preprocessor: <code class="docutils literal notranslate"><span class="pre">gospel_pps</span></code><a class="headerlink" href="#gospel-preprocessor-gospel-pps" title="Permalink to this headline">¶</a></h3>
<p>Writing attributes can be tedious, especially when nested. Gospel is provided
with a preprocessor that lets you write Gospel specifications in special
comments, starting with a <code class="docutils literal notranslate"><span class="pre">&#64;</span></code>:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">f</span><span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span>           <span class="c">(* An OCaml value declaration *)</span>
<span class="c">(*@ y = f x                 (* Its Gospel specification   *)</span>
<span class="c">    ensures x &gt; 0 *)</span>

<span class="c">(*@ type t *)</span>               <span class="c">(* A ghost type declaration   *)</span>
<span class="c">(*@ model size: int *)</span>      <span class="c">(* Its Gospel specification   *)</span>
</pre></div>
</div>
<p>This notation will be used throughout the documentation, in place of the
attribute-based one.</p>
</div>
</div>
<div class="section" id="lexical-conventions">
<h2>Lexical Conventions<a class="headerlink" href="#lexical-conventions" title="Permalink to this headline">¶</a></h2>
<p>Gospel uses the <a class="reference external" href="https://caml.inria.fr/pub/docs/manual-ocaml/lex.html">OCaml lexical conventions</a>, with the following
exceptions:</p>
<ul class="simple">
<li><p>there are reserved keywords, namely <code class="docutils literal notranslate"><span class="pre">checks</span></code>, <code class="docutils literal notranslate"><span class="pre">consumes</span></code>,
<code class="docutils literal notranslate"><span class="pre">diverges</span></code>, <code class="docutils literal notranslate"><span class="pre">ephemeral</span></code>, <code class="docutils literal notranslate"><span class="pre">equivalent</span></code>, <code class="docutils literal notranslate"><span class="pre">model</span></code>,
<code class="docutils literal notranslate"><span class="pre">modifies</span></code>, <code class="docutils literal notranslate"><span class="pre">pure</span></code>, <code class="docutils literal notranslate"><span class="pre">raises</span></code>, <code class="docutils literal notranslate"><span class="pre">requires</span></code>, <code class="docutils literal notranslate"><span class="pre">variant</span></code>,
<code class="docutils literal notranslate"><span class="pre">axiom</span></code>, <code class="docutils literal notranslate"><span class="pre">coercion</span></code>, <code class="docutils literal notranslate"><span class="pre">ensures</span></code>, <code class="docutils literal notranslate"><span class="pre">exists</span></code>, <code class="docutils literal notranslate"><span class="pre">forall</span></code>,
<code class="docutils literal notranslate"><span class="pre">invariant</span></code>, <code class="docutils literal notranslate"><span class="pre">predicate</span></code> ;</p></li>
<li><p>there are a few reserved symbols, namely <code class="docutils literal notranslate"><span class="pre">&lt;-&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">/\</span></code>, <code class="docutils literal notranslate"><span class="pre">\/</span></code>.</p></li>
</ul>
<p>In the following, <code class="docutils literal notranslate"><span class="pre">lident</span></code> (resp. <code class="docutils literal notranslate"><span class="pre">uident</span></code>) stands for an
identifier with a lowercase (resp. uppercase) first character.</p>
</div>
<div class="section" id="terms-and-formulas">
<h2>Terms and Formulas<a class="headerlink" href="#terms-and-formulas" title="Permalink to this headline">¶</a></h2>
<p>Gospel makes a distinction between terms (e.g. <code class="docutils literal notranslate"><span class="pre">x+1</span></code>) and formulas
(e.g. <code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">i.</span> <span class="pre">f</span> <span class="pre">i</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>). That distinction is made during type
checking, and not at the syntax level. Below, <code class="docutils literal notranslate"><span class="pre">expr</span></code> stands for a
Gospel expression, be it a term or a formula.</p>
<p class="rubric">Type expressions</p>
<p>Type expressions follow the OCaml syntax.</p>
<pre>
<strong id="grammar-token-typexpr">typexpr</strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">lname</span></code>
             | &quot;'&quot; <code class="xref docutils literal notranslate"><span class="pre">lident</span></code>
             | &quot;(&quot; <a class="reference internal" href="#grammar-token-typexpr"><code class="xref docutils literal notranslate"><span class="pre">typexpr</span></code></a> &quot;)&quot;
             | <a class="reference internal" href="#grammar-token-typexpr"><code class="xref docutils literal notranslate"><span class="pre">typexpr</span></code></a> <a class="reference internal" href="#grammar-token-lpath"><code class="xref docutils literal notranslate"><span class="pre">lpath</span></code></a>
             | &quot;(&quot; <a class="reference internal" href="#grammar-token-typexpr"><code class="xref docutils literal notranslate"><span class="pre">typexpr</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-typexpr"><code class="xref docutils literal notranslate"><span class="pre">typexpr</span></code></a>)+ &quot;)&quot; <a class="reference internal" href="#grammar-token-lpath"><code class="xref docutils literal notranslate"><span class="pre">lpath</span></code></a>
             | <a class="reference internal" href="#grammar-token-typexpr"><code class="xref docutils literal notranslate"><span class="pre">typexpr</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-typexpr"><code class="xref docutils literal notranslate"><span class="pre">typexpr</span></code></a>)*
             | (&quot;?&quot;? <code class="xref docutils literal notranslate"><span class="pre">lident</span></code> &quot;:&quot;)? <a class="reference internal" href="#grammar-token-typexpr"><code class="xref docutils literal notranslate"><span class="pre">typexpr</span></code></a> &quot;-&gt;&quot; <a class="reference internal" href="#grammar-token-typexpr"><code class="xref docutils literal notranslate"><span class="pre">typexpr</span></code></a>
             | <a class="reference internal" href="#grammar-token-typexpr"><code class="xref docutils literal notranslate"><span class="pre">typexpr</span></code></a> (&quot;*&quot; <a class="reference internal" href="#grammar-token-typexpr"><code class="xref docutils literal notranslate"><span class="pre">typexpr</span></code></a>)+
<strong id="grammar-token-lpath">lpath  </strong> ::=  (<a class="reference internal" href="#grammar-token-upath"><code class="xref docutils literal notranslate"><span class="pre">upath</span></code></a> &quot;.&quot;)? <code class="xref docutils literal notranslate"><span class="pre">lident</span></code>
<strong id="grammar-token-upath">upath  </strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">uident</span></code>
             | <a class="reference internal" href="#grammar-token-upath"><code class="xref docutils literal notranslate"><span class="pre">upath</span></code></a> &quot;.&quot; <code class="xref docutils literal notranslate"><span class="pre">uident</span></code>
</pre>
<p class="rubric">Expressions</p>
<p>A large fragment of the OCaml syntax is reused for Gospel expressions.</p>
<pre>
<strong id="grammar-token-expr">expr         </strong> ::=  <a class="reference internal" href="#grammar-token-constant"><code class="xref docutils literal notranslate"><span class="pre">constant</span></code></a>
                   | (<a class="reference internal" href="#grammar-token-upath"><code class="xref docutils literal notranslate"><span class="pre">upath</span></code></a> &quot;.&quot;)? <code class="xref docutils literal notranslate"><span class="pre">ident</span></code>
                   | &quot;(&quot; <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a> &quot;)&quot;
                   | &quot;(&quot; <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a>)+ &quot;)&quot;
                   | <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a> &quot;.&quot; &quot;(&quot; <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a> &quot;)&quot;
                   | <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a> <code class="xref docutils literal notranslate"><span class="pre">infix_op</span></code> <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a>
                   | <code class="xref docutils literal notranslate"><span class="pre">prefix_op</span></code> <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a>
                   | &quot;not&quot; <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a>
                   | <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a> <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a>+
                   | &quot;if&quot; <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a> &quot;then&quot; <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a> &quot;else&quot; <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a>
                   | &quot;let&quot; <a class="reference internal" href="#grammar-token-pattern"><code class="xref docutils literal notranslate"><span class="pre">pattern</span></code></a> &quot;=&quot; <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a> &quot;in&quot; <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a>
                   | &quot;match&quot; <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a>)* &quot;with&quot; <a class="reference internal" href="#grammar-token-match-cases"><code class="xref docutils literal notranslate"><span class="pre">match_cases</span></code></a>
                   | &quot;fun&quot; <a class="reference internal" href="#grammar-token-binders"><code class="xref docutils literal notranslate"><span class="pre">binders</span></code></a> &quot;-&gt;&quot; <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a>
                   | <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a> &quot;:&quot; <a class="reference internal" href="#grammar-token-typexpr"><code class="xref docutils literal notranslate"><span class="pre">typexpr</span></code></a>
                   | &quot;{&quot; <a class="reference internal" href="#grammar-token-fields"><code class="xref docutils literal notranslate"><span class="pre">fields</span></code></a> &quot;}&quot;
                   | &quot;{&quot; <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a> &quot;with` <a class="reference internal" href="#grammar-token-fields"><code class="xref docutils literal notranslate"><span class="pre">fields</span></code></a> &quot;}&quot;
                   | &quot;[&#64;...]&quot; <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a>
                   | ...
<strong id="grammar-token-binders">binders      </strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">lident</span></code>+ (&quot;:&quot; <a class="reference internal" href="#grammar-token-typexpr"><code class="xref docutils literal notranslate"><span class="pre">typexpr</span></code></a>)?
<strong id="grammar-token-pattern">pattern      </strong> ::=  &quot;_&quot;
                   | <code class="xref docutils literal notranslate"><span class="pre">lident</span></code>
                   | <code class="xref docutils literal notranslate"><span class="pre">uname</span></code> <a class="reference internal" href="#grammar-token-pattern"><code class="xref docutils literal notranslate"><span class="pre">pattern</span></code></a>?
                   | &quot;()&quot;
                   | &quot;(&quot; <a class="reference internal" href="#grammar-token-pattern"><code class="xref docutils literal notranslate"><span class="pre">pattern</span></code></a> &quot;)&quot;
                   | <a class="reference internal" href="#grammar-token-pattern"><code class="xref docutils literal notranslate"><span class="pre">pattern</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-pattern"><code class="xref docutils literal notranslate"><span class="pre">pattern</span></code></a>)+
                   | <a class="reference internal" href="#grammar-token-pattern"><code class="xref docutils literal notranslate"><span class="pre">pattern</span></code></a> &quot;::&quot; <a class="reference internal" href="#grammar-token-pattern"><code class="xref docutils literal notranslate"><span class="pre">pattern</span></code></a>
                   | <a class="reference internal" href="#grammar-token-pattern"><code class="xref docutils literal notranslate"><span class="pre">pattern</span></code></a> &quot;as` <code class="xref docutils literal notranslate"><span class="pre">lident</span></code>
                   | <a class="reference internal" href="#grammar-token-pattern"><code class="xref docutils literal notranslate"><span class="pre">pattern</span></code></a> &quot;|&quot; <a class="reference internal" href="#grammar-token-pattern"><code class="xref docutils literal notranslate"><span class="pre">pattern</span></code></a>
                   | &quot;{&quot; <code class="xref docutils literal notranslate"><span class="pre">field_pattern_</span></code> (&quot;;&quot; `field_pattern)* &quot;}&quot;
<strong id="grammar-token-field-pattern">field_pattern</strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">lname</span></code> &quot;=&quot; <a class="reference internal" href="#grammar-token-pattern"><code class="xref docutils literal notranslate"><span class="pre">pattern</span></code></a>
                   | <code class="xref docutils literal notranslate"><span class="pre">lname</span></code>
<strong id="grammar-token-match-cases">match_cases  </strong> ::=  &quot;|&quot;? <a class="reference internal" href="#grammar-token-match-case"><code class="xref docutils literal notranslate"><span class="pre">match_case</span></code></a> (&quot;|&quot; <a class="reference internal" href="#grammar-token-match-case"><code class="xref docutils literal notranslate"><span class="pre">match_case</span></code></a>)*
<strong id="grammar-token-match-case">match_case   </strong> ::=  <a class="reference internal" href="#grammar-token-pattern"><code class="xref docutils literal notranslate"><span class="pre">pattern</span></code></a> &quot;-&gt;&quot; <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a>
<strong id="grammar-token-fields">fields       </strong> ::=  <a class="reference internal" href="#grammar-token-field"><code class="xref docutils literal notranslate"><span class="pre">field</span></code></a> (&quot;;&quot; <a class="reference internal" href="#grammar-token-field"><code class="xref docutils literal notranslate"><span class="pre">field</span></code></a>)*
<strong id="grammar-token-field">field        </strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">lname</span></code> &quot;=&quot; <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a>
                   | <code class="xref docutils literal notranslate"><span class="pre">lname</span></code>
<strong id="grammar-token-constant">constant     </strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">integer_literal</span></code>
                   | <code class="xref docutils literal notranslate"><span class="pre">real_literal</span></code>
                   | &quot;true&quot; | &quot;false&quot;
                   | &quot;()&quot;
                   | &quot;[]&quot;
</pre>
<p class="rubric">Gospel-specific expressions</p>
<p>In addition, there is syntax that is specific to Gospel.</p>
<pre>
<strong id="id1">expr      </strong> ::=  ...
                | <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a> &quot;/\&quot; <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a>
                | <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a> &quot;\/&quot; <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a>
                | &quot;old&quot; <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a>
                | <a class="reference internal" href="#grammar-token-quantifier"><code class="xref docutils literal notranslate"><span class="pre">quantifier</span></code></a> <a class="reference internal" href="#grammar-token-binders"><code class="xref docutils literal notranslate"><span class="pre">binders</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-binders"><code class="xref docutils literal notranslate"><span class="pre">binders</span></code></a>)* &quot;.&quot; <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a>
                | <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a> &quot;[&quot; <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a> &quot;]&quot;
                | <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a> &quot;[&quot; <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a> &quot;&lt;-&quot; <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a> &quot;]&quot;
                | <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a> &quot;[&quot; <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a> &quot;..&quot; <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a> &quot;]&quot;
                | <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a> &quot;[&quot; &quot;..&quot; <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a> &quot;]&quot;
                | <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a> &quot;[&quot; <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a> &quot;..&quot; &quot;]&quot;
                | <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a> &quot;.&quot; &quot;(&quot; <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a> &quot;&lt;-&quot; <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a> &quot;)&quot;
<strong id="grammar-token-quantifier">quantifier</strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">forall</span></code>
                | <code class="xref docutils literal notranslate"><span class="pre">exists</span></code>
</pre>
<p>Note that <code class="docutils literal notranslate"><span class="pre">e1[e2]</span></code> is part of the OCaml syntax (application
of <code class="docutils literal notranslate"><span class="pre">e1</span></code> to a single-element list <code class="docutils literal notranslate"><span class="pre">[e2]</span></code>) but is listed here as it
has a different meaning in Gospel (namely, access to a sequence element).</p>
<p>There are two operators for logical conjunction, namely <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code> and
<code class="docutils literal notranslate"><span class="pre">/\</span></code>, and two operators for logical disjunction, namely <code class="docutils literal notranslate"><span class="pre">||</span></code> and
<code class="docutils literal notranslate"><span class="pre">\/</span></code>. A distinction between the two, if any, is tool-specific. For
instance, a deductive verification tool may interpret <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">&amp;&amp;</span> <span class="pre">B</span></code> as
<code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">/\</span> <span class="pre">(A</span> <span class="pre">-&gt;</span> <span class="pre">B)</span></code> and a runtime assertion checking tool may interpret
<code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">&amp;&amp;</span> <span class="pre">B</span></code> as a lazy operator (as in OCaml) and <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">/\</span> <span class="pre">B</span></code> as a strict
operator.</p>
<p>A noticeable difference w.r.t. the OCaml syntax is that infix
operators can be chained in Gospel. One can write <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">n</span> <span class="pre">&lt;</span> <span class="pre">100</span></code>,
for instance, and it is interpreted as <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">n</span> <span class="pre">/\</span> <span class="pre">n</span> <span class="pre">&lt;</span> <span class="pre">100</span></code>.</p>
</div>
<div class="section" id="function-contracts">
<h2>Function Contracts<a class="headerlink" href="#function-contracts" title="Permalink to this headline">¶</a></h2>
<div class="admonition-todo admonition" id="id2">
<p class="admonition-title">Todo</p>
<p>contracta for a constant e.g. val x: int (header needed? etc.)</p>
</div>
<p>An OCaml function is given a formal specification by appending one Gospel
function contract to its declaration. Here is an example:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">eucl_division</span><span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span>
<span class="c">(*@ q, r = eucl_division x y</span>
<span class="c">    requires y &gt; 0</span>
<span class="c">    ensures  x = q * y + r</span>
<span class="c">    ensures  0 &lt;= r &lt; y *)</span>
</pre></div>
</div>
<dl class="simple">
<dt>Such a contract is composed of two parts:</dt><dd><ul class="simple">
<li><p>The first line is the header of the contract; it names the function arguments
and result. It is mandatory and must appear at the beginning of the contract.</p></li>
<li><p>The next lines contain as many specification <cite>clauses</cite> as needed. Here we
have three clauses: one <a class="reference internal" href="#preconditions"><span class="std std-ref">precondition</span></a> introduced with
<code class="docutils literal notranslate"><span class="pre">requires</span></code>, and two <a class="reference internal" href="#postconditions"><span class="std std-ref">postconditions</span></a>” introduced with
<code class="docutils literal notranslate"><span class="pre">ensures</span></code>.</p></li>
</ul>
</dd>
</dl>
<pre>
<strong id="grammar-token-contract">contract   </strong> ::=  <a class="reference internal" href="#grammar-token-header"><code class="xref docutils literal notranslate"><span class="pre">header</span></code></a> <a class="reference internal" href="#grammar-token-clause"><code class="xref docutils literal notranslate"><span class="pre">clause</span></code></a>*
<strong id="grammar-token-header">header     </strong> ::=  (<a class="reference internal" href="#grammar-token-ident-tuple"><code class="xref docutils literal notranslate"><span class="pre">ident_tuple</span></code></a> &quot;=&quot;)? <code class="xref docutils literal notranslate"><span class="pre">identifier</span></code> <a class="reference internal" href="#grammar-token-parameter"><code class="xref docutils literal notranslate"><span class="pre">parameter</span></code></a>+
<strong id="grammar-token-clause">clause     </strong> ::=  <a class="reference internal" href="#grammar-token-precondition"><code class="xref docutils literal notranslate"><span class="pre">precondition</span></code></a>
                 | <a class="reference internal" href="#grammar-token-postcondition"><code class="xref docutils literal notranslate"><span class="pre">postcondition</span></code></a>
                 | <a class="reference internal" href="#grammar-token-exceptional-postcondition"><code class="xref docutils literal notranslate"><span class="pre">exceptional_postcondition</span></code></a>
                 | &quot;modifies&quot; <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a>)*
                 | <a class="reference internal" href="#grammar-token-equivalence"><code class="xref docutils literal notranslate"><span class="pre">equivalence</span></code></a>
                 | <a class="reference internal" href="#grammar-token-divergence"><code class="xref docutils literal notranslate"><span class="pre">divergence</span></code></a>
                 | &quot;consumes&quot;
<strong id="grammar-token-ident-tuple">ident_tuple</strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">identifier</span></code> (&quot;,&quot; <code class="xref docutils literal notranslate"><span class="pre">identifier</span></code>)*
<strong id="grammar-token-parameter">parameter  </strong> ::=  &quot;()&quot; | <code class="xref docutils literal notranslate"><span class="pre">identifier</span></code> | &quot;~&quot; <code class="xref docutils literal notranslate"><span class="pre">identifier</span></code> | &quot;?&quot; <code class="xref docutils literal notranslate"><span class="pre">identifier</span></code>
</pre>
<div class="admonition-todo admonition" id="id3">
<p class="admonition-title">Todo</p>
<p>ghost parameters and results</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In the absence of a contract attached to a function declaration, <strong>no
assumptions are made</strong> on the behaviour of the function.</p>
<p>No preconditions or postconditions are to be verified, and the function may
diverge, raise unlisted exceptions, or modify mutable types, etc.</p>
<p>One may still enable the implicit specification about exceptions,
mutability, non-termination, etc. by creating a contract with no clause:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">eucl_division</span><span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span>
<span class="c">(*@ q, r = eucl_division x y *)</span>
</pre></div>
</div>
<p>Here, it means that <code class="docutils literal notranslate"><span class="pre">eucl_division</span></code> terminates, does not raise
any exception, and does not have any visible side effect.</p>
</div>
<p class="rubric">Docstrings</p>
<p>Note that Gospel annotations can be combined with traditional docstrings, e.g.
as follows:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">eucl_division</span><span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span>
<span class="c">(** this is an implementation of Euclidean division *)</span>
<span class="c">(*@ q, r = eucl_division x y ... *)</span>
</pre></div>
</div>
<span class="target" id="index-0"></span><div class="section" id="preconditions">
<span id="index-1"></span><h3>Preconditions<a class="headerlink" href="#preconditions" title="Permalink to this headline">¶</a></h3>
<p>Preconditions are properties that are expected to be verified at function
entry. They are used to describe requirements on the inputs of the
function, but also possibly on a global state.</p>
<p>They are denoted using the keyword <code class="docutils literal notranslate"><span class="pre">requires</span></code> or <code class="docutils literal notranslate"><span class="pre">checks</span></code>, followed by a
<code class="xref std std-token docutils literal notranslate"><span class="pre">formula</span></code>:</p>
<pre>
<strong id="grammar-token-precondition">precondition</strong> ::=  &quot;requires&quot; <code class="xref docutils literal notranslate"><span class="pre">formula</span></code>
                  | &quot;checks&quot; <code class="xref docutils literal notranslate"><span class="pre">formula</span></code>
</pre>
<p class="rubric"><code class="docutils literal notranslate"><span class="pre">requires</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">requires</span></code> clauses state the conditions for which the specified
function has a well specified behaviour.  Whenever a <code class="docutils literal notranslate"><span class="pre">requires</span></code>
precondition is violated during a call to the function, its behaviour
becomes unspecified, and the call should be considered faulty.  Even
if the call terminates, any other information provided by the contract
(postconditions, exceptions, effects, etc.) cannot be assumed.</p>
<p>In our example, the precondition <span class="math notranslate nohighlight">\(y &gt; 0\)</span> is required to
ensure the correct behaviour of the function:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">eucl_division</span><span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span>
<span class="c">(*@ q, r = eucl_division x y</span>
<span class="hll"><span class="c">    requires y &gt; 0</span>
</span><span class="c">    ... *)</span>
</pre></div>
</div>
<p class="rubric"><code class="docutils literal notranslate"><span class="pre">checks</span></code></p>
<p>Similarly to the <code class="docutils literal notranslate"><span class="pre">requires</span></code> clauses, <code class="docutils literal notranslate"><span class="pre">checks</span></code> preconditions should
be met at function entry.  However, unlike <code class="docutils literal notranslate"><span class="pre">requires</span></code> clauses, the
behaviour of the function is specified in case such a precondition is
violated. In that case, the function must <em>fail</em> by raising an OCaml
<code class="docutils literal notranslate"><span class="pre">Invalid_argument</span></code> exception, without modifying any existing
state. The call is not considered faulty, but the caller is now in
charge of handling the exception.</p>
<p>The same function contract, where <code class="docutils literal notranslate"><span class="pre">requires</span></code> is replaced with <code class="docutils literal notranslate"><span class="pre">checks</span></code>,
states that the function should raise <code class="docutils literal notranslate"><span class="pre">Invalid_argument</span></code> whenever <span class="math notranslate nohighlight">\(y
\leq 0\)</span>.</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">eucl_division</span><span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span>
<span class="c">(*@ q, r = eucl_division x y</span>
<span class="hll"><span class="c">    checks y &gt; 0</span>
</span><span class="c">    ... *)</span>
</pre></div>
</div>
<p class="rubric">Multiple preconditions</p>
<p>Whenever multiple preconditions of the same kind are provided, they are
verified as a conjunction, which means:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="c">(*@ ...</span>
<span class="c">     requires P</span>
<span class="c">     requires Q *)</span>
</pre></div>
</div>
<p>is equivalent to:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="c">(*@ ...</span>
<span class="c">     requires P /\ Q *)</span>
</pre></div>
</div>
<p>However, splitting the specification into several, smaller clauses
leads to better readability and maintainability and is encouraged.</p>
<div class="admonition-todo admonition" id="id4">
<p class="admonition-title">Todo</p>
<p>what about requires+checks? does the order matter?</p>
</div>
</div>
<div class="section" id="postconditions">
<span id="index-2"></span><h3>Postconditions<a class="headerlink" href="#postconditions" title="Permalink to this headline">¶</a></h3>
<p>Postconditions are properties that are expected to be verified <em>after</em> a valid
function call. They are used to specify how the outputs of the function
relate to its inputs, and how values were mutated, when applicable.</p>
<p>Postconditions are denoted using the <code class="docutils literal notranslate"><span class="pre">ensures</span></code> keyword, followed by a
<code class="xref std std-token docutils literal notranslate"><span class="pre">formula</span></code>:</p>
<pre>
<strong id="grammar-token-postcondition">postcondition</strong> ::=  &quot;ensures&quot; <code class="xref docutils literal notranslate"><span class="pre">formula</span></code>
</pre>
<p>As discussed in the <a class="reference internal" href="#preconditions"><span class="std std-ref">previous section</span></a>, the
property expressed by the formula is expected to be verified after the
function call only if the preconditions were satisfied.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When an exception is raised, the postconditions are <strong>not</strong> expected to be
verified. <a class="reference internal" href="#exceptional-postconditions"><span class="std std-ref">Exceptional postconditions</span></a> must be used instead.</p>
</div>
<p class="rubric">Multiple postconditions</p>
<p>The handling of multiple postconditions is identical to preconditions; multiple
postconditions can be merged into a conjunction:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="c">(*@ ...</span>
<span class="c">     ensures P</span>
<span class="c">     ensures Q *)</span>
</pre></div>
</div>
<p>is equivalent to:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="c">(*@ ...</span>
<span class="c">     ensures P /\ Q *)</span>
</pre></div>
</div>
</div>
<div class="section" id="exceptional-postconditions">
<span id="index-3"></span><h3>Exceptional postconditions<a class="headerlink" href="#exceptional-postconditions" title="Permalink to this headline">¶</a></h3>
<p>Exceptional postconditions are used to specify the exceptions that can be raised
by the function. When no such clause is provided, the function should not raise
any exceptions, and doing so is considered a violation of the specification.
Whenever a function can raise an exception as part of its expected behaviour,
this exception must be listed, along with the properties that are verified in
that case.</p>
<p>These clauses are expressed with a <code class="docutils literal notranslate"><span class="pre">raises</span></code> keyword, followed by a
list of <code class="xref std std-token docutils literal notranslate"><span class="pre">cases</span></code> associating each exception with its
<code class="xref std std-token docutils literal notranslate"><span class="pre">formula</span></code>, with a syntax similar to OCaml’s pattern matching:</p>
<pre>
<strong id="grammar-token-exceptional-postcondition">exceptional_postcondition</strong> ::=  &quot;raises&quot; <a class="reference internal" href="#grammar-token-exn-case"><code class="xref docutils literal notranslate"><span class="pre">exn_case</span></code></a> (&quot;|&quot; <a class="reference internal" href="#grammar-token-exn-case"><code class="xref docutils literal notranslate"><span class="pre">exn_case</span></code></a>)*
<strong id="grammar-token-exn-case">exn_case                 </strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">qualid</span></code> &quot;-&gt;&quot; <code class="xref docutils literal notranslate"><span class="pre">formula</span></code>
                               | <code class="xref docutils literal notranslate"><span class="pre">qualid</span></code> <a class="reference internal" href="#grammar-token-pattern"><code class="xref docutils literal notranslate"><span class="pre">pattern</span></code></a> &quot;-&gt;&quot; <code class="xref docutils literal notranslate"><span class="pre">formula</span></code>
                               | <code class="xref docutils literal notranslate"><span class="pre">qualid</span></code>
</pre>
<p>Gospel expects each <code class="docutils literal notranslate"><span class="pre">raises</span></code> clause to perform an exhaustive pattern
matching for each exception listed in this clause. Similarly to
OCaml’s pattern matching, when an exception is raised, the
postcondition that is satisfied is the first one being matched in the
list of the cases. For instance, the contract:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="c">(*@ ...</span>
<span class="c">    raises Unix_error (ENAMETOOLONG, _, _) -&gt; P</span>
<span class="c">         | Unix_error _                    -&gt; Q *)</span>
</pre></div>
</div>
<p>states that only <code class="docutils literal notranslate"><span class="pre">P</span></code> holds whenever <code class="docutils literal notranslate"><span class="pre">Unix_error</span></code> is raised with
argument <code class="docutils literal notranslate"><span class="pre">ENAMETOOLONG</span></code>, and that only <code class="docutils literal notranslate"><span class="pre">Q</span></code> holds whenever
<code class="docutils literal notranslate"><span class="pre">Unix_error</span></code> is raised with a different argument.</p>
<p class="rubric">Multiple exceptional postconditions</p>
<p>When multiple such clauses are given, they are checked independently
of each other, meaning that the raised exception is matched against
each <code class="docutils literal notranslate"><span class="pre">raises</span></code>’s case list, and each matching postcondition must be
verified in conjunction. For instance, the contract:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="c">(*@ ...</span>
<span class="c">   raises Error &quot;foo&quot; -&gt; P | Error _ -&gt; Q</span>
<span class="c">   raises Error x -&gt; R *)</span>
</pre></div>
</div>
<dl class="simple">
<dt>implies that</dt><dd><ul class="simple">
<li><p>when <code class="docutils literal notranslate"><span class="pre">Error</span> <span class="pre">&quot;foo&quot;</span></code> is raised, both <code class="docutils literal notranslate"><span class="pre">P</span></code> and <code class="docutils literal notranslate"><span class="pre">R</span></code> hold, but not <code class="docutils literal notranslate"><span class="pre">Q</span></code>;</p></li>
<li><p>when <code class="docutils literal notranslate"><span class="pre">Error</span></code> is raised with with an argument different from
<code class="docutils literal notranslate"><span class="pre">&quot;foo&quot;</span></code>, both <code class="docutils literal notranslate"><span class="pre">Q</span></code> and <code class="docutils literal notranslate"><span class="pre">R</span></code> hold, but not <code class="docutils literal notranslate"><span class="pre">P</span></code>.</p></li>
</ul>
</dd>
</dl>
<span class="target" id="index-4"></span><p class="rubric" id="index-5">Exemptions</p>
<p>Some exceptions are not expected to be listed, because they could be
unexpectedly triggered depending on the specifics of the machine the
code is executed on.  There are two such exceptions in Gospel:
<code class="docutils literal notranslate"><span class="pre">Stack_overflow</span></code> and <code class="docutils literal notranslate"><span class="pre">Out_of_memory</span></code>.</p>
<p>These exceptions are always assumed to be possibly raised by any
function, without an explicit <code class="docutils literal notranslate"><span class="pre">raises</span></code>. This is equivalent to adding a
<code class="docutils literal notranslate"><span class="pre">raises</span> <span class="pre">Out_of_memory</span> <span class="pre">|</span> <span class="pre">Stack_overflow</span> <span class="pre">-&gt;</span> <span class="pre">true</span></code> clause to every function
contract.</p>
<p>Of course, one may still override that behaviour by stating a property
whenever these exceptions are raised, like any other exception.
For instance, one may state that a function runs in constant stack
space as follows:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="c">(*@ ...</span>
<span class="c">    raises Stack_overflow -&gt; false *)</span>
</pre></div>
</div>
</div>
<div class="section" id="code-equivalence">
<span id="index-6"></span><h3>Code equivalence<a class="headerlink" href="#code-equivalence" title="Permalink to this headline">¶</a></h3>
<p>Complementary to other specification clauses, Gospel allows the writer of the
interface to talk about <em>code equivalence</em> in the function contract. Such a code
equivalence is specified in a clause introduced by the keyword <code class="docutils literal notranslate"><span class="pre">equivalent</span></code>,
followed by a string containing the OCaml code the function should behave like.</p>
<pre>
<strong id="grammar-token-equivalence">equivalence</strong> ::=  &quot;equivalent&quot; <code class="xref docutils literal notranslate"><span class="pre">string</span></code>
</pre>
<p>This is particularly useful when specifying functions which behaviour can hardly
be expressed in pure logic:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">iter</span><span class="o">:</span> <span class="o">(</span><span class="k">&#39;</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">unit</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
<span class="c">(*@ iter f t</span>
<span class="c">    equivalent &quot;List.iter f (to_list t)&quot; *)</span>
</pre></div>
</div>
<p>With such a specification, no logical assertion is provided, but applying
<code class="docutils literal notranslate"><span class="pre">iter</span></code> to <code class="docutils literal notranslate"><span class="pre">f</span></code> and <code class="docutils literal notranslate"><span class="pre">t</span></code> is equivalent to applying <code class="docutils literal notranslate"><span class="pre">List.iter</span></code> to <code class="docutils literal notranslate"><span class="pre">f</span></code>,
and the conversion of <code class="docutils literal notranslate"><span class="pre">t</span></code> to a list. This does not leak implementation
details, as <code class="docutils literal notranslate"><span class="pre">iter</span></code> might in fact be implemented in a different, more
efficient, way, it does however make the specification concise and elegant.</p>
<div class="admonition-todo admonition" id="id5">
<p class="admonition-title">Todo</p>
<p>Warn about the OCaml code not being parsed/type-checked at the moment
(or do it).</p>
</div>
</div>
<div class="section" id="non-termination">
<span id="index-7"></span><h3>Non termination<a class="headerlink" href="#non-termination" title="Permalink to this headline">¶</a></h3>
<p>OCaml functions with attached contracts are always considered to be terminating
by default.</p>
<p>If one function is allowed to not terminate (e.g. a game or server main loop, a
function waiting for a signal or event, etc.), one can add this information to
the contract using the <code class="docutils literal notranslate"><span class="pre">diverges</span></code> keyword.</p>
<pre>
<strong id="grammar-token-divergence">divergence</strong> ::=  &quot;diverges&quot;
</pre>
<p>The following example states that the execution of the function <code class="docutils literal notranslate"><span class="pre">run</span></code> may not
terminate. It is not specified whether this function is always non-terminating
or not:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">run</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">-&gt;</span> <span class="kt">unit</span>
<span class="c">(*@ run ()</span>
<span class="c">    diverges *)</span>
</pre></div>
</div>
<span class="target" id="index-8"></span></div>
<div class="section" id="effects">
<span id="index-9"></span><h3>Effects<a class="headerlink" href="#effects" title="Permalink to this headline">¶</a></h3>
<div class="admonition-todo admonition" id="id6">
<p class="admonition-title">Todo</p>
<p>do it</p>
</div>
<div class="admonition-todo admonition" id="id7">
<p class="admonition-title">Todo</p>
<p>when we have ensures+raises+modifies, the effect stated by
modifies applies for both ensures and raises</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">modifies</span></code>…
<code class="docutils literal notranslate"><span class="pre">consumes</span></code>…</p>
<span class="target" id="index-10"></span><span class="target" id="index-11"></span><span class="target" id="index-12"></span></div>
</div>
<div class="section" id="type-specification">
<span id="index-13"></span><h2>Type Specification<a class="headerlink" href="#type-specification" title="Permalink to this headline">¶</a></h2>
<div class="admonition-todo admonition" id="id8">
<p class="admonition-title">Todo</p>
<p>do it</p>
</div>
<span class="target" id="index-14"></span><span class="target" id="index-15"></span><span class="target" id="index-16"></span></div>
<div class="section" id="ghost-and-logical-declarations">
<span id="index-17"></span><h2>Ghost and Logical Declarations<a class="headerlink" href="#ghost-and-logical-declarations" title="Permalink to this headline">¶</a></h2>
<div class="admonition-todo admonition" id="id9">
<p class="admonition-title">Todo</p>
<p>do it</p>
</div>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">GOSPEL</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="starting.html">Starting Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="tools.html">Example Tools</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Language Specification</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#specification-locations">Specification locations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#lexical-conventions">Lexical Conventions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#terms-and-formulas">Terms and Formulas</a></li>
<li class="toctree-l2"><a class="reference internal" href="#function-contracts">Function Contracts</a></li>
<li class="toctree-l2"><a class="reference internal" href="#type-specification">Type Specification</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ghost-and-logical-declarations">Ghost and Logical Declarations</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="api.html">Gospel API</a></li>
<li class="toctree-l1"><a class="reference internal" href="genindex.html">Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="todos.html">Documentation TODOs</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="tools.html" title="previous chapter">Example Tools</a></li>
      <li>Next: <a href="api.html" title="next chapter">Gospel API</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, VOCaL team.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/language.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>